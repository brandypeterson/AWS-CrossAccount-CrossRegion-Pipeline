AWSTemplateFormatVersion: '2010-09-09'
Description: Cross account primary stack.
Parameters:
  DeploymentOrgPath:
    Type: String
Resources:
  # This KMS key is for use with the cross account build/deploment. The permermissions allow the
  # CrossAccountCodePipeline role within the deployment organization to use the key.
  KMSKey:
    Type: 'AWS::KMS::Key'
    Properties:
      Description: Used by Assumed Roles in deploy accounts to Encrypt/Decrypt code
      EnableKeyRotation: true
      KeyPolicy:
        Version: '2012-10-17'
        Id: !Ref 'AWS::StackName'
        Statement:
          - Sid: Allows admin of the key
            Effect: Allow
            Principal:
              AWS: !Sub 'arn:aws:iam::${AWS::AccountId}:root'
            Action:
              - 'kms:Create*'
              - 'kms:Describe*'
              - 'kms:Enable*'
              - 'kms:List*'
              - 'kms:Put*'
              - 'kms:Update*'
              - 'kms:Revoke*'
              - 'kms:Disable*'
              - 'kms:Get*'
              - 'kms:Delete*'
              - 'kms:ScheduleKeyDeletion'
              - 'kms:CancelKeyDeletion'
              - 'kms:Encrypt'
              - 'kms:Decrypt'
              - 'kms:ReEncrypt*'
              - 'kms:GenerateDataKey*'
              - 'kms:DescribeKey'
            Resource: '*'
          - Effect: Allow
            Principal: '*'
            Action:
              - 'kms:Encrypt'
              - 'kms:Decrypt'
              - 'kms:ReEncrypt*'
              - 'kms:GenerateDataKey*'
              - 'kms:DescribeKey'
            Resource: '*'
            Condition:
              ArnEquals:
                aws:PrincipalArn: !Sub arn:aws:iam::${AWS::AccountId}:role/CrossAccountCodePipeline
          - Effect: Allow
            Principal: '*'
            Action:
              - 'kms:Encrypt'
              - 'kms:Decrypt'
              - 'kms:ReEncrypt*'
              - 'kms:GenerateDataKey*'
              - 'kms:DescribeKey'
            Resource: '*'
            Condition:
              ArnLike:
                aws:PrincipalArn: arn:aws:iam::*:role/CrossAccountCodePipeline
              ForAnyValue:StringLike:
                aws:PrincipalOrgPaths:
                  - !Ref DeploymentOrgPath

  KMSAlias:
    Type: 'AWS::KMS::Alias'
    Properties:
      AliasName: alias/codepipeline-crossaccounts
      TargetKeyId: !Ref KMSKey

  # Topic to be used for manual intervention notification in a pipeline.
  ManualInterventionTopic:
    Type: 'AWS::SNS::Topic'
    Properties:
      DisplayName: Topic for pipeline manual intervention notifications
      TopicName: PipelineManualIntervention

  # Role for the sync artifacts function.
  SyncArtifactsRole:
    Type: 'AWS::IAM::Role'
    Properties:
      RoleName: CrossAccountPipelineSyncArtifacts
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - !Ref SyncArtifactsPolicy
        - 'arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'

  # This policy gives the sync artifacts function permission to decrypt with KMS key
  # and to send updates to CodePipeline.
  SyncArtifactsPolicy:
    Type: 'AWS::IAM::ManagedPolicy'
    Properties:
      ManagedPolicyName: CrossAccountPipelineSyncArtifacts
      Description: Policy for syncing artifact data for cross account pipelines
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Action:
              - 'kms:Decrypt'
            Effect: Allow
            Resource:
              - !GetAtt KMSKey.Arn
          - Action:
              - 'codepipeline:*' # pretty sure this doesn't need to be star.
            Effect: Allow
            Resource: '*'

  # This function takes the artifacts supplied to it and makes sure they are available in the
  # requested region. This function should be called from CodePipeline. The CodePipeline step
  # should include all the input artifacts that will be needed in the destination region.
  SyncArtifactsFunction:
    Type: 'AWS::Lambda::Function'
    Properties:
      Code:
        ZipFile:
          'Fn::Join':
            - |+

            - - const aws = require('aws-sdk');
              - "const s3 = new aws.S3({region: 'us-east-1'});"
              - const codepipeline = new aws.CodePipeline();
              - const path = require('path');
              - ''
              - 'exports.handler = function main(event, context) {'
              - '  console.log(JSON.stringify(event));'
              - '  // Retrieve the Job ID from the Lambda action'
              - '  let jobId = event["CodePipeline.job"].id;'
              - '  try {'
              - '    let data = JSON.parse(event["CodePipeline.job"].data.actionConfiguration.configuration.UserParameters);'
              - '    let destBucket = data.DestinationBucket;'
              - '  '
              - '    // Make a task for each combination of record and destBucket'
              - '    let tasks = [];'
              - '  '
              - '    for (var i = 0; i < event["CodePipeline.job"].data.inputArtifacts.length; i++) {'
              - '      const sourceBucket = event["CodePipeline.job"].data.inputArtifacts[i].location.s3Location.bucketName;'
              - '      const sourceKey = event["CodePipeline.job"].data.inputArtifacts[i].location.s3Location.objectKey;'
              - '  '
              - '      if (sourceBucket != destBucket)'
              - '        tasks.push(replicatePromise(sourceBucket, sourceKey.replace(/\+/g, " "), destBucket));'
              - '      }'
              - '  '
              - '    if (tasks.length != 0) {'
              - '      Promise.all(tasks)'
              - '        .then(() => {'
              - "          putJobSuccess(jobId, 'Successfully synced artifacts', context);"
              - '        })'
              - '        .catch((e) => {'
              - '          putJobFailure(jobId, e, context);'
              - '        });'
              - '    } else {'
              - "      putJobSuccess(jobId, 'No need to sync', context);"
              - '    }'
              - '  }'
              - '  catch(ex) {'
              - '    putJobFailure(jobId, ex, context);'
              - '  }'
              - '};'
              - ''
              - ' // Notify AWS CodePipeline of a successful job'
              - 'function putJobSuccess(jobId, message, context) {'
              - '  var params = {'
              - '    jobId: jobId'
              - '  };'
              - '  codepipeline.putJobSuccessResult(params, function(err, data) {'
              - '    if(err) {'
              - '      context.fail(err);'
              - '    }'
              - '    else {'
              - '      context.succeed(message);'
              - '    }'
              - '  });'
              - '};'
              - ''
              - // Notify AWS CodePipeline of a failed job
              - 'function putJobFailure(jobId, message, context) {'
              - '  var params = {'
              - '    jobId: jobId,'
              - '    failureDetails: {'
              - '      message: JSON.stringify(message),'
              - "      type: 'JobFailed',"
              - '      externalExecutionId: context.invokeid'
              - '    }'
              - '  };'
              - '  codepipeline.putJobFailureResult(params, function(err, data) {'
              - '    context.fail(message);'
              - '  });'
              - '};'
              - ''
              - 'function replicatePromise(sourceBucket, sourceKey, destBucket) {'
              - '  return new Promise((resolve, reject) => {'
              - '    var destKey = sourceKey;'
              - "    var msg = 'copying ' + sourceBucket + ':' + sourceKey + ' to ' + destBucket + ':' + destKey;"
              - ''
              - "    console.log('Attempting: ' + msg);"
              - '    s3.copyObject({'
              - '      Bucket: destBucket,'
              - '      Key: destKey,'
              - "      CopySource: encodeURIComponent(sourceBucket + '/' + sourceKey),"
              - "      MetadataDirective: 'COPY'"
              - '    }, (err, data) => {'
              - '      if (err) {'
              - "        console.log('Error:' + msg);"
              - '        console.log(err, err.stack); // an error occurred'
              - "        return reject('Error:' + msg);"
              - '      } else {'
              - "        console.log('Success: ' + msg);"
              - "        return resolve('Success: ' + msg);"
              - '      }'
              - '    });'
              - '  });'
              - '}'
              - ''
              - 'function sleep(ms){'
              - '    return new Promise(resolve=>{'
              - '        setTimeout(resolve,ms)'
              - '    })'
              - '}'
      Description: Makes sure the input artifacts are in the right bucket.
      FunctionName: CrossAccountPipelineSyncArtifacts
      Handler: index.handler
      MemorySize: 128
      Role: !GetAtt SyncArtifactsRole.Arn
      Runtime: nodejs10.x
      Timeout: 30

  # Basic permissions to allow CodePipeline to call the sync function.
  SyncArtifactsLambdaPermission:
    Type: 'AWS::Lambda::Permission'
    Properties:
      Action: 'lambda:InvokeFunction'
      FunctionName: !Ref SyncArtifactsFunction
      Principal: codepipeline.amazonaws.com
      SourceAccount: !Ref 'AWS::AccountId'
      SourceArn: !Sub 'arn:aws:codepipeline:${AWS::Region}:${AWS::AccountId}:*'

  # This is the bucket where build artifacts are put. CodeBuild should place things here, and
  # CodePipeline should trigger off specific artifacts.
  BuildBucket:
    Type: 'AWS::S3::Bucket'
    Properties:
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      VersioningConfiguration:
        Status: Enabled
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              KMSMasterKeyID: !GetAtt KMSKey.Arn
              SSEAlgorithm: 'aws:kms'

  # This is the bucket that is used for CodePipeline, in the primary region
  PipelineBucket:
    Type: 'AWS::S3::Bucket'
    Properties:
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              KMSMasterKeyID: !GetAtt KMSKey.Arn
              SSEAlgorithm: 'aws:kms'

  # Grant access to the cross account CloudFormation and CodePipeline roles within the deployment
  # organization
  PipelineBucketPolicy:
    Type: 'AWS::S3::BucketPolicy'
    Properties:
      Bucket: !Ref PipelineBucket
      PolicyDocument:
        Statement:
          - Action:
              - 's3:*' # TODO: this doesn't need to be star
            Effect: Allow
            Resource:
              - !Sub 'arn:aws:s3:::${PipelineBucket}'
              - !Sub 'arn:aws:s3:::${PipelineBucket}/*'
            Principal: '*'
            Condition:
              ArnLike:
                aws:PrincipalArn: arn:aws:iam::*:role/CrossAccountCloudFormation
              ForAnyValue:StringLike:
                aws:PrincipalOrgPaths:
                  - !Ref DeploymentOrgPath
          - Action:
              - 's3:*' # TODO: this doesn't need to be star
            Effect: Allow
            Resource:
              - !Sub 'arn:aws:s3:::${PipelineBucket}'
              - !Sub 'arn:aws:s3:::${PipelineBucket}/*'
            Principal: '*'
            Condition:
              ArnLike:
                aws:PrincipalArn: arn:aws:iam::*:role/CrossAccountCodePipeline
              ForAnyValue:StringLike:
                aws:PrincipalOrgPaths:
                  - !Ref DeploymentOrgPath

Outputs:
  CMK:
    Description: The CMK that is used for cross account access
    Value: !GetAtt KMSKey.Arn
    Export:
      Name: CrossAccountCMK
  BuildBucket:
    Description: The bucket for the builds
    Value: !Ref BuildBucket
    Export:
      Name: BuildBucket
  PipelineBucket:
    Description: The bucket for the pipeline
    Value: !Ref PipelineBucket
    Export:
      Name: PipelineBucket
  SyncArtifactsFunction:
    Description: The function for syncing artifacts
    Value: !Ref SyncArtifactsFunction
    Export:
      Name: SyncArtifactsFunction
  SyncArtifactsFunctionArn:
    Description: The function for syncing artifacts
    Value: !GetAtt SyncArtifactsFunction.Arn
    Export:
      Name: SyncArtifactsFunctionArn
