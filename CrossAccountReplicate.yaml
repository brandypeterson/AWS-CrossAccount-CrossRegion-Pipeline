AWSTemplateFormatVersion: '2010-09-09'
Description: Cross account developer replication stack.
Parameters:
  # DeveloperOrgPath:
  #   Type: String
  CustomResourceServiceSnsTopicArn:
    Type: String
Resources:
  # this table is used to manage where to replicate the build artifacts to
  Table:
    Type: 'AWS::DynamoDB::Table'
    Properties:
      TableName: CrossAccountBuildReplication
      AttributeDefinitions:
        - AttributeName: pk
          AttributeType: S
        - AttributeName: sk
          AttributeType: S
        - AttributeName: gsi1_pk
          AttributeType: S
        - AttributeName: gsi1_sk
          AttributeType: S
      BillingMode: PAY_PER_REQUEST
      GlobalSecondaryIndexes:
        - IndexName: gsi1
          KeySchema:
            - AttributeName: gsi1_pk
              KeyType: HASH
            - AttributeName: gsi1_sk
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
      KeySchema:
        - AttributeName: pk
          KeyType: HASH
        - AttributeName: sk
          KeyType: RANGE

  # Role for the replication registration function.
  ReplicationRegistrationRole:
    Type: 'AWS::IAM::Role'
    Properties:
      RoleName: CrossAccountPipelineS3ReplicationRegistration
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - !Ref ReplicationRegistrationPolicy
        - 'arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole' # I don't really like this policy

  # This policy allows the replication registration function to write data in the DynamoDB table
  ReplicationRegistrationPolicy:
    Type: 'AWS::IAM::ManagedPolicy'
    Properties:
      ManagedPolicyName: CrossAccountPipelineS3ReplicationRegistration
      Description: Policy for replicating S3 data for developer account pipelines
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Action:
              - 'dynamodb:DeleteItem'
              - 'dynamodb:PutItem'
            Effect: Allow
            Resource:
              - !GetAtt Table.Arn

  ReplicationRegistrationFunction:
    Type: 'AWS::Lambda::Function'
    Properties:
      Code:
        # Modify this function handle the registration request and add/remove the record in the table
        ZipFile: |
          const AWS = require('aws-sdk')
          const dynamoDB = new AWS.DynamoDB.DocumentClient();

          exports.handler = async function main(event, context) {
            try {
              const id = event.PhysicalResourceId || (Math.random().toString(36).substring(2, 16) + Math.random().toString(36).substring(2, 16)).toUpperCase();

              if (event.RequestType === 'Create') {
                await dynamoDB.put({
                  ConditionExpression: `attribute_not_exists(pk)`,
                  TableName: 'CrossAccountBuildReplication',
                  Item: {
                    pk: id,
                    sk: 'Primary',
                    gsi1_pk: 'ReplicateBuildArtifact',
                    gsi1_sk: `Bucket|${id}`,
                    id: id,
                    bucketArn: event.ResourceProperties.BucketArn,
                    accountId: event.ResourceProperties.AccountId,
                    region: event.ResourceProperties.Region
                  }
                }).promise();
              }
              else if (event.RequestType === 'Update') {
                await dynamoDB.put({
                  ConditionExpression: `attribute_exists(pk)`,
                  TableName: 'CrossAccountBuildReplication',
                  Item: {
                    pk: id,
                    sk: 'Primary',
                    gsi1_pk: 'ReplicateBuildArtifact',
                    gsi1_sk: `Bucket|${id}`,
                    id: id,
                    bucketArn: event.ResourceProperties.BucketArn,
                    accountId: event.ResourceProperties.AccountId,
                    region: event.ResourceProperties.Region
                  }
                }).promise();
              }
              else if (event.RequestType === 'Delete') {
                await dynamoDB.delete({
                  TableName: 'CrossAccountBuildReplication',
                  Key: {
                    "pk": id,
                    sk: 'Primary'
                  }
                }).promise();
              }
              else {
                return {
                  Status: "FAILED",
                  reason: `Unknown RequestType '${event.RequestType}'`
                };
              }

              return {
                Status: "SUCCESS",
                PhysicalResourceId: id,
                Data: {
                  Name: "TheName"
                }
              };
            }
            catch (e) {
              console.error(e);
              return {
                Status: "FAILED",
                reason: `Error registering.`
              };
            }
          };
      Description: Registers a bucket in a developer account for replication
      FunctionName: CrossAccountReplicationRegistration
      Handler: index.handler
      MemorySize: 128
      Role: !GetAtt ReplicationRegistrationRole.Arn
      Runtime: nodejs10.x
      Timeout: 30

  # Role for the replication function to be called by the CloudFormationCustomResourceServiceSnsTopic.
  ReplicationRegistrationInvokeRole:
    Type: 'AWS::IAM::Role'
    Properties:
      RoleName: ReplicationRegistrationInvokeRole
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              AWS: arn:aws:iam::471161320350:role/CloudFormation-CustomResourceService-CallEndpoint-us-west-2
            Action: 'sts:AssumeRole'
            # Condition:
            #   ArnLike:
            #     aws:PrincipalArn: !Ref CustomResourceServiceSnsTopicArn
      ManagedPolicyArns:
        - !Ref ReplicationRegistrationInvokePolicy

  # This policy allows the replication function to read data from the build bucket.
  ReplicationRegistrationInvokePolicy:
    Type: 'AWS::IAM::ManagedPolicy'
    Properties:
      ManagedPolicyName: ReplicationRegistrationInvokePolicy
      Description: Policy for invoking the registration function
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Action:
              - 'lambda:InvokeFunction'
            Effect: Allow
            Resource: !GetAtt ReplicationRegistrationFunction.Arn

  # # topic to use as the endpoint for custom resources to register for replication
  # ReplicationRegistrationTopic:
  #   Type: AWS::SNS::Topic
  #   Properties:
  #     Subscription:
  #       - Endpoint: !GetAtt ReplicationRegistrationFunction.Arn
  #         Protocol: lambda
  #     TopicName: BuildArtifactReplicationRegistration

  # # This policy allows any account within the developer org to call the SNS topic
  # ReplicationRegistrationTopicPolicy:
  #   Type: AWS::SNS::TopicPolicy
  #   Properties:
  #     Topics:
  #       - !Ref ReplicationRegistrationTopic
  #     PolicyDocument:
  #       Version: 2012-10-17
  #       Statement:
  #         - Effect: Allow
  #           Principal: '*'
  #           Action:
  #             - sns:Publish
  #           Resource: !Ref ReplicationRegistrationTopic
  #           Condition:
  #             ArnLike:
  #               aws:PrincipalArn: arn:aws:iam::*:role/CrossAccount-CloudFormation
  #             ForAnyValue:StringLike:
  #               aws:PrincipalOrgPaths:
  #                 - !Ref DeveloperOrgPath

  # permission for the SNS topic to call the lambda function
  # LambdaInvokePermission:
  #   Type: AWS::Lambda::Permission
  #   Properties:
  #     Action: lambda:InvokeFunction
  #     Principal: sns.amazonaws.com
  #     SourceArn: !Ref ReplicationRegistrationTopic
  #     FunctionName: !GetAtt ReplicationRegistrationFunction.Arn

  # Role for the replication function.
  ReplicationRole:
    Type: 'AWS::IAM::Role'
    Properties:
      RoleName: CrossAccountPipelineS3Replication
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - !Ref ReplicationPolicy
        - 'arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'

  # This policy allows the replication function to read data from the build bucket.
  ReplicationPolicy:
    Type: 'AWS::IAM::ManagedPolicy'
    Properties:
      ManagedPolicyName: CrossAccountPipelineS3Replication
      Description: Policy for replicating S3 data for developer account pipelines
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Action:
              - 's3:ListBucket'
            Effect: Allow
            Resource:
              - 'Fn::Sub':
                  - 'arn:aws:s3:::${Bucket}'
                  - Bucket: !ImportValue BuildBucket
          - Action:
              - 's3:Get*'
            Effect: Allow
            Resource:
              - 'Fn::Sub':
                  - 'arn:aws:s3:::${Bucket}/*'
                  - Bucket: !ImportValue BuildBucket
          - Action:
              - 'kms:Decrypt'
            Effect: Allow
            Resource: !ImportValue CrossAccountCMK
          - Action:
              - 'dynamodb:Query'
            Effect: Allow
            Resource:
              - 'Fn::Sub':
                  - '${Arn}/index/*'
                  - Arn: !GetAtt Table.Arn

  # This function is triggered on created objects in the build bucket and copies the objects to
  # the developer accounts.
  ReplicationFunction:
    Type: 'AWS::Lambda::Function'
    Properties:
      Code:
        ZipFile: |
          // Modify this function to get the bucket list from the above DynamoDB table
          const AWS = require('aws-sdk')
          const s3 = new AWS.S3({ region: 'us-east-1' });
          const dynamoDB = new AWS.DynamoDB.DocumentClient();

          exports.handler = async function main(event, context) {
            const destBuckets = await getDestinationBuckets();

            if (event.Records === null) {
              context.fail('Error: Event has no records.');
              return;
            }

            // Make a task for each combination of record and destBucket
            let tasks = [];
            for (let i = 0; i < event.Records.length; i++) {
              for (let j = 0; j < destBuckets.length; j++) {
                tasks.push(replicatePromise(event.Records[i], destBuckets[j]));
              }
            }

            await Promise.all(tasks);
          };

          async function getDestinationBuckets() {
            const input = {
              TableName: 'CrossAccountBuildReplication',
              IndexName: 'gsi1',
              KeyConditionExpressions: '#pk = :pk AND begins_with(#sk, :begins)',
              ExpressionAttributeName: {
                '#pk': 'gsi1_pk',
                '#sk': 'gsi1_sk'
              },
              ExpressionAttributeValues: {
                ':pk': 'ReplicateBuildArtifact',
                ':begins': 'Bucket|'
              }
            };

            const output = await dynamoDB.query(input).promise();

            return output.Items.map(i => i.bucketArn);
          }

          function replicatePromise(record, destBucket) {
            return new Promise((resolve, reject) => {
              // The source bucket and source key are part of the event data
              var srcBucket = record.s3.bucket.name;
              var srcKey = decodeURIComponent(record.s3.object.key.replace(/\+/g, " "));
              var srcVersion = record.s3.object.version;

              // Modify destKey if an alternate copy location is preferred
              var destKey = srcKey;
              var msg = 'copying ' + srcBucket + ':' + srcKey + ' to ' + destBucket + ':' + destKey;

              console.log('Attempting: ' + msg);
              s3.copyObject({
                Bucket: destBucket,
                Key: destKey,
                ACL: 'bucket-owner-full-control',
                CopySource: encodeURIComponent(srcBucket + '/' + srcKey + (srcVersion ? ('?versionId=' + srcVersion) : '')),
                MetadataDirective: 'COPY'
              }, (err, data) => {
                if (err) {
                  console.log('Error:' + msg);
                  console.log(err, err.stack); // an error occurred
                  return reject('Error:' + msg);
                }
                else {
                  console.log('Success: ' + msg);
                  return resolve('Success: ' + msg);
                }
              });
            });
          }
      Description: Copies data from on S3 bucket to a list of destination buckets.
      FunctionName: S3DataReplicator
      Handler: index.handler
      MemorySize: 128
      Role: !GetAtt ReplicationRole.Arn
      Runtime: nodejs10.x
      Timeout: 30

  # Basic permissions to allow the replication function to be triggered by the build bucket.
  ReplicationLambdaPermission:
    Type: 'AWS::Lambda::Permission'
    Properties:
      Action: 'lambda:InvokeFunction'
      FunctionName: !Ref ReplicationFunction
      Principal: s3.amazonaws.com
      SourceAccount: !Ref 'AWS::AccountId'
      SourceArn:
        'Fn::Sub':
          - 'arn:aws:s3:::${Bucket}'
          - Bucket: !ImportValue BuildBucket

  # This role is only to allow the custom resource for adding a bucket notification to the
  # build bucket. This is a custom resource because bucket notification is part of the bucket
  # definition, which we don't control here, so we need to add it via an API call instead.
  ApplyNotificationFunctionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Path: /
      Policies:
        - PolicyName: S3BucketNotificationPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Sid: AllowBucketNotification
                Effect: Allow
                Action: s3:PutBucketNotification
                Resource:
                  - 'Fn::Sub':
                      - 'arn:aws:s3:::${Bucket}'
                      - Bucket: !ImportValue BuildBucket
                  - 'Fn::Sub':
                      - 'arn:aws:s3:::${Bucket}/*'
                      - Bucket: !ImportValue BuildBucket

  # This function is for adding a bucket notification to the build bucket. This is a custom
  # resource because bucket notification is part of the bucket definition, which we don't control
  # here, so we need to add it via an API call instead. It is only called during deployment of this
  # stack.
  ApplyBucketNotificationFunction:
    Type: AWS::Lambda::Function
    Properties:
      Description: Dummy function, just logs the received event
      Handler: index.handler
      Runtime: python2.7
      Role: !GetAtt 'ApplyNotificationFunctionRole.Arn'
      Timeout: 240
      Code:
        ZipFile: |
          import boto3
          import logging
          import json
          import cfnresponse

          s3Client = boto3.client('s3')
          logger = logging.getLogger()
          logger.setLevel(logging.DEBUG)

          def addBucketNotification(bucketName, notificationId, functionArn):
            notificationResponse = s3Client.put_bucket_notification_configuration(
              Bucket=bucketName,
              NotificationConfiguration={
                'LambdaFunctionConfigurations': [
                  {
                    'Id': notificationId,
                    'LambdaFunctionArn': functionArn,
                    'Events': [
                      's3:ObjectCreated:*'
                    ]
                  },
                ]
              }
            )
            return notificationResponse

          def create(properties, physical_id):
            bucketName = properties['S3Bucket']
            notificationId = properties['NotificationId']
            functionArn = properties['FunctionARN']
            response = addBucketNotification(bucketName, notificationId, functionArn)
            logger.info('AddBucketNotification response: %s' % json.dumps(response))
            return cfnresponse.SUCCESS, physical_id

          def update(properties, physical_id):
            return cfnresponse.SUCCESS, None

          def delete(properties, physical_id):
            return cfnresponse.SUCCESS, None

          def handler(event, context):
            logger.info('Received event: %s' % json.dumps(event))

            status = cfnresponse.FAILED
            new_physical_id = None

            try:
              properties = event.get('ResourceProperties')
              physical_id = event.get('PhysicalResourceId')

              status, new_physical_id = {
                'Create': create,
                'Update': update,
                'Delete': delete
              }.get(event['RequestType'], lambda x, y: (cfnresponse.FAILED, None))(properties, physical_id)
            except Exception as e:
              logger.error('Exception: %s' % e)
              status = cfnresponse.FAILED
            finally:
              cfnresponse.send(event, context, status, {}, new_physical_id)

  # This custom resource creates the notification on the build bucket so that we can trigger a
  # lambda whenever something is created in the build bucket. This is a custom resource because
  # bucket notification is part of the bucket definition, which we don't control here, so we need
  # to add it via an API call instead.
  ApplyNotification:
    Type: Custom::ApplyNotification
    Properties:
      ServiceToken: !GetAtt 'ApplyBucketNotificationFunction.Arn'
      S3Bucket: !ImportValue BuildBucket
      FunctionARN: !GetAtt ReplicationFunction.Arn
      NotificationId: S3ObjectCreatedEvent

Outputs:
  ReplicationFunctionArn:
    Description: The function for replication build artifacts
    Value: !GetAtt ReplicationFunction.Arn
    Export:
      Name: ReplicationFunctionArn
  ReplicationRoleArn:
    Description: The role used for replication.
    Value: !GetAtt ReplicationRole.Arn
  ApplyBucketNotificationFunctionArn:
    Description: The ARN of the function to apply a bucket notification to the build bucket
    Value: !GetAtt ApplyBucketNotificationFunction.Arn
    Export:
      Name: ApplyBucketNotificationFunctionArn
  # ReplicationRegistrationTopicArn:
  #   Description: The ARN of the SNS topic that is used as the 'ServiceToken' of the custom resources
  #   Value: !Ref ReplicationRegistrationTopic
  #   Export:
  #     Name: ReplicationRegistrationTopicArn
  ReplicationRegistrationInvokeRoleArn:
    Description: The role ARN for the registration call
    Value: !GetAtt ReplicationRegistrationInvokeRole.Arn
    Export:
      Name: ReplicationRegistrationInvokeRoleArn
